# Целевая платформа
Приложение разрабатывалось на эмуляторе iPhone 12 iOS 15.5   
Необходимые разрешения добавлены в android часть также, но не тестировались.

# Результаты
## Приложение чата
Целью Study Jam 2 было используя предоставленный API с документацией и шаблоном чата модернизировать его выполнив определенный перечень заданий разной сложности. В выполненном проекте присутствует реализация всех заявленных задач.

## Используемые библиотеки
- `surf_study_jam` - пакет с  API клиентом для Surf Study Jam 2
- `equatable` - пакет, расширяя класс от которого можно не описывать реализацию методов оператора 
сравнения и хэш кода у классов
- `bloc` - dart пакет для реализации паттерна BLoC
- `flutter_bloc` - пакет виджетов для упрощения работы с пакетом `bloc`
- `shared_preferences` - пакет для доступа к локальному хранилищу
- `get_it` - пакет сервис локатора
- `intl` - пакет интернационализации, тут для преобразования форматов даты и времени
- `map_launcher` - пакет для открытия установленного приложения карт с передачей в него параметров
- `geolocator` - пакет для получения текущего местоположения
- `image_picker` - пакет для реализации возможности выбора изображений
- `bubble` - пакет для отображения сообщений чата в виде пузырьков

## Экран авторизации
Экран авторизации два текстовых поля с возможностью очистки введенного значения, кнопку 'Далее' и отображает линейный индикатор прогресса, который появляется после нажатия на кнопку "Далее", когда в состоянии кубита авторизации `AuthCubit` появляется параметр отвечающий за состояние загрузки. После окончания загрузки состояние сменяется и соответствующий BlocListener выполняет навигацию на следующую страницу.

### Сообщения об ошибке
На экране авторизации помимо сообщения об ошибке от API о неверно введенном логине/пароле также
отображается сообщение о незаполненных полях формы.
<p align="center">
  <img src="https://user-images.githubusercontent.com/30658712/184511693-b449ce39-e0d7-4cb4-99bf-c8ceec7e6d17.gif">
</p>

## Навигация
Навигация построена на базе Navigator 1.0 и именованных маршрутов. При старте приложения
выполняется проверка валидности сохраненного в локальном хранилище токена. Далее осуществляется
автоматический переход на экран списка тем в случае, если токен валиден и на экран
авторизации в случае, если авторизоваться с помощью токена не удалось.
### Сохранение токена
Одновременно с переходом на следующую страницу с помощью фичи `settings` через кубит настроек 
`AppSettingsCubit` и его функций осуществляется сохранение полученного токена в локальное
хранилище для проверки его валидности при следующем входе.
### Выход из чата
При нажатии кнопки назад на экране тем происходит обнуление токена в хранилище и вызов метода 
`logout` клиента.
<p align="center">
  <img src="https://user-images.githubusercontent.com/30658712/184511476-8ad7a3cf-777f-46c6-89be-63861c571ac1.gif">
</p>

## Имя пользователя в AppBar списка тем
Имя пользователя при отображении страницы с темами получается с помощью
дополнительно реализованного метода репозитория `IChatRepository` `getLocalUser()`,
который выполняет метод `getUser()` без параметра из API и получает объект локального 
пользователя из ответа.   
Имена пользователей синхронизируются с github и при разовом сохранении его в локальном хранилище 
при входе и последующем обновлении имени в github в интерфейсе изменений не произойдет, будет 
необходимо выполнять повторную авторизацию.
<p align="center">
  <img width="400" src="https://user-images.githubusercontent.com/30658712/184511787-36acc6c1-9b0c-4d00-b39f-2eb7cd2d73af.png">
</p>

## Открытие темы и отправка сообщений в разные темы
Для получения сообщений из определенной темы и для отправки сообщения в определенную тему во все методы
репозитория `IChatRepository` добавлен параметр `chatId`.

## Создание темы
Для создания новой темы реализована страница создания темы. На экране расположены два 
текстовых поля, значения которых проверяются на пустоту при попытке создать тему.   
Дополнительно на экране расположена строка с предварительным просмотром будущего аватара 
создаваемой темы. При написании названия цвет аватара и текст меняются в зависимости от 
содержимого поля с названием чата.   
Также реализована возможность загружать изображение и устанавливать его в качестве аватара 
темы. Загрузка изображения осуществляется с помощью фичи `image_upload` описанной ранее. 
После загрузки цветной круг с текстом заменяется загруженным изображением.
При создании темы ссылка на загруженное изображение отправляется в параметре `avatar`
модели `ChatTopicSendDto` наряду с полученными из текстовых полей параметров `name` и `description`.
После создания темы осуществляется переход в чат этой темы. При навигации назад происходит переход в список чатов.
<p align="center">
  <img src="https://user-images.githubusercontent.com/30658712/184512695-36c39eab-7a15-45f3-9c69-4a25e6c3b3c1.gif">
</p>

## Название чата
В AppBar на странице чата отображается строка с названием чата, получаемое из модели ChatTopicDto
и сохраняемое в стейте кубита тем `TopicsCubit` при переходе с экрана тем и получаемое из 
него на экране чата.
<p align="center">
  <img width="400" src="https://user-images.githubusercontent.com/30658712/184513329-64e344f2-826d-4abf-97c4-fd3cdc00e505.jpg">
</p>

## Перемещение в конец чата
Для быстрого перемещения в конец списка сообщений добавлена специальная кнопка, прокручивающая 
список до конца.
<p align="center">
  <img width="400" src="https://user-images.githubusercontent.com/30658712/184513862-06516130-2d4f-400c-980c-45866216552e.jpg">
</p>

## Открытие карты
Открытие карты реализовано с помощью библиотеки `map_launcher`. В ней можно либо отобразить список
доступных на устройстве карт, либо открыть первую имеющуюся.   
При нажатии на кнопку "Открыть на карте" открывается первая доступная на устройстве карта 
и в нее передается помимо координаты также имя метки на карте, представляющее из себя имя пользователя и 
и текст "тут". Получается метка на карте с надписью "имя_пользователя тут". 
<p align="center">
  <img src="https://user-images.githubusercontent.com/30658712/184514741-d117f9a3-49a3-4ab8-ac1b-a25aea90f86a.gif">
</p>

## Отправка геолокации
Для работы с геолокацией создана отдельная фича `location` с источником данных, репозиторием и кубитом,
выполняющего запрос в репозиторий,сменяющего состояния получения геолокации и обрабатывающего 
возникающие ошибки. При прикреплении геолокации данные прикрепляются настоящие, факт их 
прикрепления отображается полоской с текстом над полем ввода текста сообщения. Есть возможность 
убрать прикрепленную геолокацию в случае ее ошибочного прикрепления путем нажатия на 
соответствующую кнопку.
<p align="center">
  <img src="https://user-images.githubusercontent.com/30658712/184515334-512c994f-1812-495f-9ff6-fbd08bde179d.gif">
</p>

## Отображение изображений
Для компактного размещения изображения отображаются с помощью GridView.
<p align="center">
  <img width="400" src="https://user-images.githubusercontent.com/30658712/184515382-89ee54ea-a923-4947-b3df-2b2ec61d7a19.jpg">
</p>

## Отправка изображений
### Выбор изображений
Для выбора изображений для отправки используется пакет `image_picker`, который позволяет
открыть системное окно выбора изображений и после подтверждения выбора получить список объектов
типа XFile. Далее полученный список изображений загружается в хранилище с помощью реализованной 
фичи `image_upload`.

### Отправка изображений
>🔥Наибольшее количество времени, если сравнивать с другими заданиями, ушло на реализацию 
>отправки изображений. Firebase использовать не хотелось, поэтому был осуществлен поиск доступных 
> хранилищ изображений с загрузкой по API. Таковых сходу нашлось, исходя из критерия бесплатности, два: 
> https://freeimage.host/ и https://imgbb.com/. Последний хоть и позволяет загружать и имеет механизм
> удаления загруженной картинки, но имеет на сайте упоминание о платных тарифах. Был выбран первый вариант.

Для загрузки изображений реализована фича `image_upload`. В ней описана модель ответа и
парсинг из JSON этой модели. Для реализации запроса к API реализован источник данных, 
который получает зависимостью http клиент. Метод `uploadImage(File imageFile)` источника
данных получает параметром объект с типом File, кодирует его в строку base64 и добавляет к 
телу запроса, получает ответ и, в случае успешности, десериализует его в модель. В ответе 
используется единственный параметр - строка со ссылкой на загруженное изображение.
Для отслеживания состояния загрузки реализован ImageUploadCubit  с методом
`uploadImage(List<XFile> imageFileList)`, который получает список файлов от `ImagePicker`, последовательно 
отправляет их в источник данных на загрузку и при получении ссылки на загруженное изображение выдает 
обновленное состояние со списком ссылок на изображения. 
В интерфейсе реализован `BlocBuilder`, который при обновлении состояния и появлении ссылок в списке 
последовательно отображает их в интерфейсе в `GridView`. При нажатии кнопки "Отправить" список ссылок 
добавляется в параметр `images` при отправке. После отправки список изображений очищается.
<p align="center">
  <img src="https://user-images.githubusercontent.com/30658712/184515602-d8f5cb33-f373-419f-bffc-39cc66a8534f.gif">
</p>

## Кнопка отправить
При нажатии кнопки отправить происходит проверка, какие данные для отправки были подготовлены и 
в зависимости от наличия локации или изображения или при отсутствии и того и другого отправляет 
соответствующий тип сообщения.

## Отображение времени
Для удобства добавлено отображение времени отправки сообщения. Время преобразуется к локальному 
и форматируется в нужный для отображения вид.

## Аватарки
Цвет аватарки получается путем бинарной операции или над шестнадцатиричным значением черного
цвета и хэш кода строки с именем. Ввиду того, что у пользователей могло не быть имени, состоящего
из двух слов, алгоритм формирования текста внутри аватара необходимо было изменить.

## Баблы
Для баблов используется библиотека bubble, настроены отступы и выступ сверху. Но не вынесен аватар из бабла, но об этом ниже =)

## Константы и утилиты
Тема приложения вынесена в отдельный класс. Константы также имеют свой отдельный класс, на настоящий
момент туда успели попасть константы названий путей роутинга, адреса, пути и параметры запроса
к API загрузки изображений и наблюдатель состояний блока/кубита.

## TODO (пока доступно api)
[ ] Ввиду ограниченного времени пришлось делать выбор - реализовывать задачи или реализовать архитектуру. 
В итоге фичи `chat` и `topics` не реализованы полноценно с точки зрения менеджмента состояний. В них заложено использование `cubit`, но времени на полноценную реализацию функций и состояний не хватило. Основное, что хотелось успеть добавить - стейт загрузки, получения данных и ошибки для
отображения, для демонстрации индикатора загрузки и отображения сообщения об ошибке, приходящего, например, в случае когда в топике нет сообщений.   
[ ] Отправка и отображение комбинированного сообщения с геолокацией и изображением, добавить для этого модель и соответствующие методы в репозиторий.   
[ ] Сохранение позиции скролла при переходе в конкретный чат с экрана тем. Смещение скрола после отправки сообщения.   
[ ] Дизайн не был приоритетным. Как я уже сейчас вижу настолько неприоритетным, что даже аватарки не вынесены из баблов и ни у каких типов сообщений, 
кроме обычного не реализована проверка `isUserLocal` для отображения цвета своего сообщения, исправить =) И сделать скругление аватрок топиков.

# Полная демонстрация работы

[Полное видео демонстрации работы](https://disk.yandex.ru/i/88DxE6H7fye3Dw)
